// ===================== StudentDashboard.jsx (Part 1/2) ===================== import { useEffect, useMemo, useRef, useState } from "react"; import { Link, useNavigate } from "react-router-dom"; import { getPrograms, YEARS } from "../data/eduData.js"; /* ================= Utils ================ */ function safeParse(json) { try { return JSON.parse(json || ""); } catch { return null; } } function initials(name = "") { const parts = name.trim().split(/\s+/).filter(Boolean); return ((parts[0]?.[0] || "S") + (parts[1]?.[0] || "K")).toUpperCase(); } const RAW_NAME_TO_ISO = { Nigeria:"NG", Kenya:"KE", Tanzania:"TZ","United Republic of Tanzania":"TZ", Ghana:"GH", Uganda:"UG", "South Africa":"ZA", Ethiopia:"ET", Algeria:"DZ", Angola:"AO", Benin:"BJ", Botswana:"BW", "Burkina Faso":"BF", Burundi:"BI", Cameroon:"CM","Cape Verde":"CV","Central African Republic":"CF", Chad:"TD", Congo:"CG", "Republic of the Congo":"CG","Congo DR":"CD","DR Congo":"CD","Democratic Republic of the Congo":"CD", Djibouti:"DJ", Egypt:"EG","Equatorial Guinea":"GQ", Eritrea:"ER","Eswatini (Swaziland)":"SZ", Eswatini:"SZ", Swaziland:"SZ", Gabon:"GA", Gambia:"GM", Guinea:"GN","Ivory Coast":"CI","Cote d'Ivoire":"CI","C√¥te d‚ÄôIvoire":"CI", Lesotho:"LS", Liberia:"LR", Libya:"LY", Madagascar:"MG", Malawi:"MW", Mali:"ML", Mauritania:"MR", Mauritius:"MU", Morocco:"MA", Mozambique:"MZ", Namibia:"NA", Niger:"NE", Reunion:"RE", Rwanda:"RW", Senegal:"SN", Seychelles:"SC","Sierra Leone":"SL", Somalia:"SO","South Sudan":"SS", Sudan:"SD", Togo:"TG", Tunisia:"TN", Zambia:"ZM", Zimbabwe:"ZW", }; const canon = (s="") => s.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^\p{L}\p{N}]+/gu," ").trim(); const NAME_TO_ISO_CANON = Object.fromEntries(Object.entries(RAW_NAME_TO_ISO).map(([k,v]) => [canon(k), v])); const normalizeCountry = (s="") => s.replace(/\s+/g," ").trim(); const isoFromCountryName = (country="") => NAME_TO_ISO_CANON[canon(country)] || ""; const ensureCountryCode = (country, countryCode) => { const cc = String(countryCode || "").toUpperCase().trim(); if (cc.length === 2) return cc; return isoFromCountryName(country) || ""; }; /** Flag (from FlagCDN) */ function FlagIcon({ country, countryCode, className = "w-6 h-4" }) { const cc = ensureCountryCode(country, countryCode); if (!cc) return <span className={inline-block ${className}}>üåç</span>; const lo = https://flagcdn.com/w40/${cc.toLowerCase()}.png; const hi = https://flagcdn.com/w80/${cc.toLowerCase()}.png; const svg = https://flagcdn.com/${cc.toLowerCase()}.svg; return ( <img src={lo} srcSet={${lo} 1x, ${hi} 2x} alt={${country} flag} className={inline-block align-[-2px] rounded-[2px] ${className}} width={24} height={16} onError={(e) => { e.currentTarget.onerror = null; e.currentTarget.src = svg; }} loading="lazy" /> ); } /* ---- Display helpers ---- */ const facultyDisplay = (u) => (u?.faculty && u.faculty.trim()) || "College/School/Faculty/Department"; /* Audience helpers */ const audienceKey = ({ university, faculty, program, year }) => ${university}__${faculty}__${program}__${year}; const facultyAudienceKey = ({ university, faculty }) => FACULTY__${university}__${faculty}; const facultyYearAudienceKey = ({ university, faculty, year }) => FACULTY__${university}__${faculty}__${year}; // Notifications helpers const NOTIF_SEEN_KEY = (uid) => notifSeen_${uid}; const LECT_LAST_NOTIFY_KEY = (uid) => lectLastNotify_${uid}; const NOTIF_CLEARED_KEY = (uid) => notifCleared_${uid}; /** Is a post for this student‚Äôs audience? (Program, Faculty, Faculty+Year, or GLOBAL) */ function isMyAudience(p, u, baseFac, audKey) { if (!p?.audience) return false; if (p.audience === "GLOBAL") return true; if (p.audience === audKey) return true; if (p.audience === baseFac) return true; if (p.audience === ${baseFac}__${u.year}) return true; return false; } /* ===== Attachments: IndexedDB ===== */ const DB_NAME = "sk_attachments"; const STORE = "files"; function openDB() { return new Promise((resolve, reject) => { const req = indexedDB.open(DB_NAME, 1); req.onupgradeneeded = (e) => { const db = e.target.result; if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); }; req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); }); } async function idbSet(key, blob) { const db = await openDB(); return new Promise((res, rej) => { const tx = db.transaction(STORE, "readwrite"); tx.objectStore(STORE).put(blob, key); tx.oncomplete = () => res(true); tx.onerror = () => rej(tx.error); }); } async function idbGet(key) { const db = await openDB(); return new Promise((res, rej) => { const tx = db.transaction(STORE, "readonly"); const r = tx.objectStore(STORE).get(key); r.onsuccess = () => res(r.result || null); r.onerror = () => rej(r.error); }); } function dataURLtoBlob(dataUrl) { const [hdr, b64] = dataUrl.split(","); const mime = (hdr.match(/data:(.*?);base64/) || [, "application/octet-stream"])[1]; const bin = atob(b64); const len = bin.length; const bytes = new Uint8Array(len); for (let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i); return new Blob([bytes], { type: mime }); } /* Small thumbnails we can keep in localStorage safely */ async function makeThumb(dataUrl, maxW = 360, maxH = 360, quality = 0.72) { return new Promise((resolve) => { const img = new Image(); img.onload = () => { const r = Math.min(1, maxW / img.width, maxH / img.height); const w = Math.max(1, Math.round(img.width * r)); const h = Math.max(1, Math.round(img.height * r)); const c = document.createElement("canvas"); c.width = w; c.height = h; const ctx = c.getContext("2d"); ctx.drawImage(img, 0, 0, w, h); resolve(c.toDataURL("image/jpeg", quality)); }; img.onerror = () => resolve(dataUrl); // fallback img.src = dataUrl; }); } /* Image downscale & file readers for inputs */ async function fileToDownscaledDataURL(file, maxW, maxH, quality = 0.84, targetKB = 480) { const blobUrl = URL.createObjectURL(file); try { const img = await new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = blobUrl; }); const ratio = Math.min(1, maxW / img.width, maxH / img.height); const w = Math.max(1, Math.round(img.width * ratio)); const h = Math.max(1, Math.round(img.height * ratio)); const canvas = document.createElement("canvas"); canvas.width = w; canvas.height = h; const ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0, w, h); let q = quality, dataURL = canvas.toDataURL("image/jpeg", q), TARGET = targetKB * 1024; while (dataURL.length * 0.75 > TARGET && q > 0.5) { q -= 0.06; dataURL = canvas.toDataURL("image/jpeg", q); } return dataURL; } finally { URL.revokeObjectURL(blobUrl); } } function readFileAsDataURL(file) { return new Promise((resolve, reject) => { const r = new FileReader(); r.onload = () => resolve(r.result); r.onerror = reject; r.readAsDataURL(file); }); } /* Storage helpers */ const trySet = (k, v) => { try { localStorage.setItem(k, v); return true; } catch { return false; } }; const ID_KEYS = ["authUserId","activeUserId","currentUserId","loggedInUserId"]; function persistUser(user) { sessionStorage.setItem("currentUser", JSON.stringify(user)); for (const k of ID_KEYS) sessionStorage.setItem(k, user.id); trySet("currentUser", JSON.stringify(user)); for (const k of ID_KEYS) trySet(k, user.id); const users = safeParse(localStorage.getItem("users")) || []; const idx = users.findIndex(u => u.id === user.id); if (idx >= 0) users[idx] = user; else users.push(user); trySet("users", JSON.stringify(users)); const map = safeParse(localStorage.getItem("usersById")) || {}; map[user.id] = user; trySet("usersById", JSON.stringify(map)); } function loadActiveUser() { for (const src of [sessionStorage, localStorage]) { for (const key of ID_KEYS) { const id = src.getItem(key); if (id) { const byId = safeParse(localStorage.getItem("usersById")) || {}; if (byId[id]) return byId[id]; const arr = safeParse(localStorage.getItem("users")) || []; const found = arr.find(u => u.id === id || u.uid === id || u.userId === id); if (found) return found; } } } const ss = safeParse(sessionStorage.getItem("currentUser")); if (ss) return ss; const ls = safeParse(localStorage.getItem("currentUser")); if (ls) return ls; return null; } function saveAndBroadcastUser(nextUser) { persistUser(nextUser); try { localStorage.setItem("currentUser", JSON.stringify(nextUser)); } catch {} try { sessionStorage.setItem("currentUser", JSON.stringify(nextUser)); } catch {} window.dispatchEvent(new Event("user:updated")); } /* ================= Sample base ================= */ const POST_TYPES = ["Notes","Assignments","Announcement","Scholarships","Academic Books","Researches/Thesis"]; const initialUser = { id:"u1", name:"Student Name", photoUrl:"", bannerUrl:"", continent:"Africa", country:"Nigeria", countryCode:"NG", university:"University", faculty:"Faculty", program:"Program", year:"1st Year", }; /* ================= Reusable UI ================= */ function Card({ className="", children }) { return <div className={rounded-2xl border border-slate-100 bg-white p-4 shadow-sm ${className}}>{children}</div>; } function DashLink({ to, label }) { return <Link to={to} className="block rounded px-2 py-2 hover:bg-slate-50 text-slate-700 text-center">{label}</Link>; } /* NEW: Academic Platform style header bar + square sidebar card */ function HeaderBar({ title }) { return <div className="px-4 py-2.5 bg-[#7bdad1]/90 text-slate-900 text-sm font-semibold text-center">{title}</div>; } function SidebarCard({ title, children }) { return ( <div className="rounded-none overflow-hidden border border-slate-200 bg-white shadow-sm"> {title ? <HeaderBar title={title} /> : null} <div className="p-3">{children}</div> </div> ); } function FilterPill({ label, active, onClick, activeClassName, showNew=false }) { return ( <button type="button" onClick={onClick} className={w-full px-3 py-2 rounded-full text-sm flex items-center ${ active ? (activeClassName || "bg-slate-900 text-white") : "border border-slate-100 hover:bg-slate-50 text-left" }} > <span className="truncate">{label}</span> {!active && showNew && ( <span className="ml-2 inline-flex items-center rounded-full px-1.5 py-0.5 text-[10px] font-extrabold text-white bg-red-600 animate-pulse"> NEW </span> )} </button> ); } function ToolbarButton({ onClick, label, title }) { return <button type="button" onClick={onClick} title={title} className="rounded border border-slate-100 px-2 py-1 text-sm hover:bg-slate-50">{label}</button>; } function Avatar({ size="md", url, name, online=false }) { const sizeClass = size==="lg"?"h-16 w-16":size==="sm"?"h-8 w-8":"h-10 w-10"; const cls = ${sizeClass} relative rounded-full bg-slate-300 flex items-center justify-center overflow-hidden; return ( <div className={cls}> {url ? <img src={url} alt={name} className="h-full w-full object-cover rounded-full" /> : <div className="h-full w-full flex items-center justify-center text-white text-sm bg-gradient-to-tr from-blue-500 to-indigo-500">{initials(name)}</div>} {online && <span className="absolute -bottom-0.5 -right-0.5 h-3 w-3 rounded-full bg-emerald-500 ring-2 ring-white" title="Online" />} </div> ); } function stripHtml(s=""){ const d=document.createElement("div"); d.innerHTML=s; return (d.textContent||d.innerText||"").trim(); } function ExpandableText({ text, initialChars=180 }) { const [open,setOpen]=useState(false); if(!text) return null; const tooLong = text.length>initialChars, shown = open||!tooLong?text:text.slice(0,initialChars)+"‚Ä¶"; return <div className="mt-1 text-slate-800"><span>{shown}</span>{tooLong&&<button onClick={()=>setOpen(v=>!v)} className="ml-2 text-blue-600 hover:underline"> {open?"Read less":"Read more"}</button>}</div>; } function ExpandableHtml({ html, initialChars=280 }) { const [open,setOpen]=useState(false); const plain=stripHtml(html); const tooLong=plain.length>initialChars; const shortHtml=plain.slice(0,initialChars)+(tooLong?"‚Ä¶":""); return <div className="mt-3 text-slate-800 prose-sm max-w-none">{open||!tooLong?<div dangerouslySetInnerHTML={{__html:html}}/>:<div>{shortHtml}</div>}{tooLong&&<button onClick={()=>setOpen(v=>!v)} className="mt-1 text-blue-600 text-sm hover:underline">{open?"Read less":"Read more"}</button>}</div>; } function NewBadge({ show }) { if (!show) return null; return <span className="mr-2 inline-flex items-center px-2 py-0.5 rounded-full text-[11px] font-extrabold text-white bg-emerald-600 shadow-[0_0_12px_rgba(16,185,129,0.9)] animate-pulse">NEW</span>; } const stop = (e) => { e.preventDefault(); e.stopPropagation(); }; /* ---------- Attachment resolvers ---------- */ function useAttachmentUrl(att, preferFull=true) { const [url, setUrl] = useState(att?.dataUrl || (preferFull ? null : att?.thumb || null)); useEffect(() => { let toRevoke = null; let cancelled = false; if (!url && att?.id) { (async () => { const blob = await idbGet(att.id); if (cancelled) return; if (blob) { const obj = URL.createObjectURL(blob); toRevoke = obj; setUrl(obj); } else if (att.thumb) { setUrl(att.thumb); } })(); } return () => { cancelled = true; if (toRevoke) URL.revokeObjectURL(toRevoke); }; }, [att?.id]); // eslint-disable-line react-hooks/exhaustive-deps return url; } function AttachmentImage({ att, className="", onClick, enlarge=false }) { const url = useAttachmentUrl(att, enlarge); if (!url) return null; return <img src={url} alt={att.name || "image"} className={className} onClick={onClick} loading="lazy" />; } function AttachmentLink({ att }) { const url = useAttachmentUrl(att, true); if (!url) return <span className="text-slate-400">{att.name || "file"}</span>; return <a href={url} download={att.name || "file"} target="_blank" rel="noopener noreferrer" className="underline">{att.name || "file"}</a>; } /* ---------- Reusable grid ---------- */ function ImageGrid({ images=[], onOpen, max=3, tileClass="h-40", cols="grid-cols-2 md:grid-cols-3", className="", withArrows=true }) { const len = images.length || 0; const [offset, setOffset] = useState(0); useEffect(()=>{ setOffset(0); }, [len]); if (len === 0) return null; const count = Math.min(max, len); const indices = Array.from({length: count}, (_,i)=> (offset + i) % len); const showArrows = withArrows && len > max; const next = () => setOffset(o => (o + 1) % len); const prev = () => setOffset(o => (o - 1 + len) % len); return ( <div className={relative ${className}}> <div className={grid ${cols} gap-2}> {indices.map((gi, idx) => { const img = images[gi]; const isLast = idx === indices.length - 1 && len > max; return ( <div key={(img.id||img.dataUrl||img.name||"img")+gi} className="relative"> <AttachmentImage att={img} className={w-full ${tileClass} object-cover rounded cursor-zoom-in} onClick={() => onOpen(gi)} /> {isLast && ( <button type="button" onClick={() => onOpen(gi)} className="absolute inset-0 rounded bg-black/50 text-white font-semibold text-sm md:text-base flex items-center justify-center" title="View more photos"> +{len - max} more </button> )} </div> ); })} </div> {showArrows && ( <> <button type="button" onClick={(e)=>{ stop(e); prev(); }} className="absolute left-1 top-1/2 -translate-y-1/2 bg-white/90 rounded-full px-2 py-1 text-lg shadow" aria-label="Previous" title="Previous">‚Äπ</button> <button type="button" onClick={(e)=>{ stop(e); next(); }} className="absolute right-1 top-1/2 -translate-y-1/2 bg-white/90 rounded-full px-2 py-1 text-lg shadow" aria-label="Next" title="Next">‚Ä∫</button> </> )} </div> ); } /* ====== NEW: Click-to-play YouTube ====== */ function VideoCard({ videoId, title, by, publishedAt }) { const [playing, setPlaying] = useState(false); const thumb = https://img.youtube.com/vi/${videoId}/hqdefault.jpg; return ( <div className="rounded-2xl border border-slate-100 shadow-sm p-3 bg-white"> <div className="aspect-video w-full overflow-hidden rounded-xl bg-gray-100"> {playing ? ( <iframe className="w-full h-full" src={https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0} title={title} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen /> ) : ( <button onClick={() => setPlaying(true)} className="relative w-full h-full" aria-label={Play ${title}}> <img src={thumb} alt={title} className="w-full h-full object-cover" /> <span className="absolute inset-0 grid place-items-center"> <span className="rounded-full px-4 py-2 bg-black/60 text-white text-sm">‚ñ∂ Play</span> </span> </button> )} </div> <div className="mt-3"> <h4 className="font-semibold">{title}</h4> <p className="text-sm text-gray-500">{by} ‚Ä¢ {new Date(publishedAt).toLocaleDateString()}</p> </div> </div> ); } function VideoGallery({ videos = [], audience = "student" }) { const list = videos.filter(v => v.audience === audience || v.audience === "both"); if (!list.length) return null; return ( <div className="grid gap-4"> {list.map(v => ( <VideoCard key={v.id} videoId={v.youtubeId} title={v.title} by={v.by} publishedAt={v.publishedAt} /> ))} </div> ); } /* ====== NEW: Consent Form (email preferences) ====== */ const CONSENT_DEFAULT = { scholarshipAlerts: false, applicationTips: false, programRecommendations: false, applicationInvitations: false, }; function ConsentForm({ userId, initialConsents, onSave }) { const [consents, setConsents] = useState({ ...CONSENT_DEFAULT, ...(initialConsents || {}) }); const [saving, setSaving] = useState(false); useEffect(() => { if (initialConsents) setConsents(prev => ({ ...prev, ...initialConsents })); }, [initialConsents]); const handleChange = (k) => (e) => setConsents({ ...consents, [k]: e.target.checked }); const handleSubmit = async (e) => { e.preventDefault(); setSaving(true); const payload = { ...consents, consentVersion: 1, consentUpdatedAt: new Date().toISOString(), }; try { await onSave?.(userId, payload); } finally { setSaving(false); } }; return ( <form onSubmit={handleSubmit} className="rounded-2xl border p-4 bg-white space-y-3"> <h3 className="text-lg font-semibold">Email Preferences & Consent</h3> <p className="text-sm text-gray-600">Select the updates you‚Äôd like to receive. You can change this anytime.</p> <label className="flex items-start gap-3"> <input type="checkbox" className="mt-1" checked={consents.scholarshipAlerts} onChange={handleChange("scholarshipAlerts")} /> <span><span className="font-medium">Scholarship Alerts</span><br/><span className="text-sm text-gray-600">Deadlines, eligibility, and new opportunities.</span></span> </label> <label className="flex items-start gap-3"> <input type="checkbox" className="mt-1" checked={consents.applicationTips} onChange={handleChange("applicationTips")} /> <span><span className="font-medium">University Application Tips</span><br/><span className="text-sm text-gray-600">How to prepare strong applications.</span></span> </label> <label className="flex items-start gap-3"> <input type="checkbox" className="mt-1" checked={consents.programRecommendations} onChange={handleChange("programRecommendations")} /> <span><span className="font-medium">Program Recommendations</span><br/><span className="text-sm text-gray-600">Matches based on your interests and profile.</span></span> </label> <label className="flex items-start gap-3"> <input type="checkbox" className="mt-1" checked={consents.applicationInvitations} onChange={handleChange("applicationInvitations")} /> <span><span className="font-medium">University Application Invitations</span><br/><span className="text-sm text-gray-600">Direct invitations from partner universities.</span></span> </label> <p className="text-xs text-gray-500">By selecting any option, you consent to receive emails for that category from ScholarsKnowledge. See our Privacy Policy.</p> <button type="submit" disabled={saving} className="rounded-xl px-4 py-2 bg-black text-white disabled:opacity-60"> {saving ? "Saving..." : "Save preferences"} </button> </form> ); } /* ====== Comment thread (unchanged UI; trimmed in Part 1) ====== */ function CommentThread({ comment, onAddReply, onOpenLightbox }) { const [reply,setReply]=useState(""); const [replyImages,setReplyImages]=useState([]); const [replyFiles,setReplyFiles]=useState([]); const onPickReplyImages = async (e)=>{ const files = Array.from(e.target.files||[]).filter(f=>f.type.startsWith("image/")); const dataUrls = await Promise.all(files.map(f=>fileToDownscaledDataURL(f, 1280, 1280, 0.82, 420))); const mapped = dataUrls.map((dataUrl,i)=>({name:files[i].name, dataUrl})); setReplyImages(arr=>[...arr, ...mapped]); e.target.value=""; }; const onPickReplyDocs = async (e)=>{ const files = Array.from(e.target.files||[]); const mapped = await Promise.all(files.map(async f=>({ name:f.name, mime:f.type||"application/octet-stream", dataUrl: await readFileAsDataURL(f) }))); setReplyFiles(arr=>[...arr, ...mapped]); e.target.value=""; }; return ( <div className="text-sm"> <div className="flex items-start gap-2"> <Avatar size="sm" url={comment.authorPhoto} name={comment.author}/> <div className="flex-1"> <div className="font-medium text-slate-800">{comment.author}</div> <div className="text-xs text-slate-500 mb-1">{comment.authorProgram||""}</div> <ExpandableText text={comment.text}/> {comment.images?.length>0 && ( <div className="mt-2"> <ImageGrid images={comment.images} onOpen={(idx)=>onOpenLightbox(comment.images, idx)} max={3} tileClass="h-28" withArrows /> </div> )} {comment.files?.length>0 && ( <ul className="mt-2 space-y-1"> {comment.files.map((f,idx)=>( <li key={idx} className="flex items-center gap-2">üìé <AttachmentLink att={f} /></li> ))} </ul> )} {comment.replies?.length>0 && ( <div className="mt-2 pl-6 space-y-2"> {comment.replies.map(r=>( <div key={r.id} className="flex items-start gap-2"> <Avatar size="sm" url={r.authorPhoto} name={r.author}/> <div> <div className="font-medium text-slate-800">{r.author}</div> <div className="text-xs text-slate-500 mb-1">{r.authorProgram||""}</div> <ExpandableText text={r.text}/> {r.images?.length>0 && ( <div className="mt-2"> <ImageGrid images={r.images} onOpen={(idx)=>onOpenLightbox(r.images, idx)} max={3} tileClass="h-24" withArrows /> </div> )} {r.files?.length>0 && ( <ul className="mt-2 space-y-1"> {r.files.map((f,i)=>( <li key={i} className="flex items-center gap-2">üìé <AttachmentLink att={f} /></li> ))} </ul> )} </div> </div> ))} </div> )} <form onSubmit={(e)=>{e.preventDefault(); onAddReply(reply, replyImages, replyFiles); setReply(""); setReplyImages([]); setReplyFiles([]); }} className="mt-2" > <div className="flex items-start gap-2"> <input value={reply} onChange={e=>setReply(e.target.value)} placeholder="Write a reply‚Ä¶" className="flex-1 border border-slate-100 rounded-full px-3 py-1.5"/> <label className="text-xs px-2 py-1 border border-slate-100 rounded cursor-pointer">üì∑ <input type="file" accept="image/*" multiple className="hidden" onChange={onPickReplyImages}/> </label> <label className="text-xs px-2 py-1 border border-slate-100 rounded cursor-pointer">üìé <input type="file" multiple className="hidden" onChange={onPickReplyDocs} accept=".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.txt"/> </label> <button type="submit" className="rounded-full border border-slate-100 px-3 py-1 hover:bg-slate-50">Reply</button> </div> </form> </div> </div> </div> ); } /* ====== Post card (same UI; lightbox trimmed for brevity here‚Äîfull in Part 2) ====== */ function PostCard({ post, onToggleLike, onAddComment, onAddReply, currentUser, isHighlighted }) { const [showComments,setShowComments]=useState(true); const [cmt,setCmt]=useState(""); const [cmtImages,setCmtImages]=useState([]); const [cmtFiles,setCmtFiles]=useState([]); const [lightbox, setLightbox] = useState({ open:false, items:[], index:0 }); const onPickCmtImages = async (e)=>{ const files = Array.from(e.target.files||[]).filter(f=>f.type.startsWith("image/")); const dataUrls = await Promise.all(files.map(f=>fileToDownscaledDataURL(f, 1280, 1280, 0.82, 420))); const mapped = dataUrls.map((dataUrl,i)=>({name:files[i].name, dataUrl})); setCmtImages(arr=>[...arr, ...mapped]); e.target.value=""; }; const onPickCmtDocs = async (e)=>{ const files = Array.from(e.target.files||[]); const mapped = await Promise.all(files.map(async f=>({ name:f.name, mime:f.type||"application/octet-stream", dataUrl: await readFileAsDataURL(f)}))); setCmtFiles(arr=>[...arr, ...mapped]); e.target.value=""; }; const openLightbox = (items = [], index = 0) => { if (!Array.isArray(items) || items.length === 0) return; setLightbox({ open: true, items: items.slice(), index: Math.max(0, Math.min(index, items.length - 1)) }); }; const closeLightbox = () => setLightbox(l => ({ ...l, open:false })); const step = (dir) => setLightbox(l => { const len = l.items?.length || 0; if (len <= 1) return l; return { ...l, index: (l.index + dir + len) % len }; }); useEffect(()=>{ if (!lightbox.open) return; const onKey = (e) => { if (e.key === "ArrowRight") step(1); else if (e.key === "ArrowLeft") step(-1); else if (e.key === "Escape") closeLightbox(); }; window.addEventListener("keydown", onKey); return () => window.removeEventListener("keydown", onKey); }, [lightbox.open]); const images = post.images || []; return ( <div className={rounded-2xl border bg-white p-4 ${isHighlighted ? "border-amber-400 ring-2 ring-amber-300" : "border-slate-100"}}> <div className="flex items-center gap-3"> <Avatar size="md" url={post.authorPhoto} name={post.author}/> <div className="min-w-0"> <div className="font-semibold text-slate-900 truncate">{post.author}</div> <div className="text-xs text-slate-500"> {post.authorProgram||post.type} ‚Ä¢ {post.time} ‚Ä¢ {post.audience==="GLOBAL"?"Public":post.audience.startsWith("FACULTY__")?"Faculty":"Program"} </div> </div> <span className="ml-auto text-xs rounded-full border border-slate-100 px-2 py-0.5">{post.type}</span> </div> {post.title && (<h3 className="mt-3 text-base md:text-lg font-semibold text-slate-900">{post.title}</h3>)} <ExpandableHtml html={post.html}/> {images.length>0 && ( <div className="mt-3"> <ImageGrid images={images} onOpen={(idx)=>openLightbox(images, idx)} max={3} tileClass="h-40" withArrows /> </div> )} {lightbox.open && ( <div className="fixed inset-0 z-[80] bg-black/70 flex items-center justify-center p-4" onClick={closeLightbox}> <div className="relative max-w-6xl w-full pointer-events-auto" onClick={stop} onMouseDown={stop}> <AttachmentImage key={lightbox.items[lightbox.index]?.id || lightbox.index} att={lightbox.items[lightbox.index]} enlarge className="w-full max-h-[88vh] object-contain rounded" /> <button type="button" className="absolute -top-3 -right-3 bg-white rounded-full px-2 py-1 text-sm shadow z-10" onClick={(e)=>{ stop(e); closeLightbox(); }} aria-label="Close">‚úï</button> {lightbox.items.length>1 && ( <> <button type="button" className="absolute left-2 top-1/2 -translate-y-1/2 bg-white/90 rounded-full px-3 py-2 text-xl shadow z-10" onClick={(e)=>{ stop(e); step(-1); }} aria-label="Previous" title="Previous">‚Äπ</button> <button type="button" className="absolute right-2 top-1/2 -translate-y-1/2 bg-white/90 rounded-full px-3 py-2 text-xl shadow z-10" onClick={(e)=>{ stop(e); step(1); }} aria-label="Next" title="Next">‚Ä∫</button> </> )} </div> </div> )} {post.files?.length>0 && ( <ul className="mt-2 text-sm text-slate-700 space-y-1"> {post.files.map((f,i)=> (<li key={${(f.id||f.name||"f")}-${i}} className="flex items-center gap-2">üìé <AttachmentLink att={f} /></li>))} </ul> )} <div className="mt-3 flex items-center gap-6 text-sm text-slate-600"> <button onClick={onToggleLike} className="flex items-center gap-2 rounded px-2 py-1 hover:bg-slate-50"> <svg viewBox="0 0 20 20" className="w-4 h-4" fill={post.liked?"currentColor":"none"} stroke="currentColor"><path d="M10 17l-1.45-1.32C4.4 11.36 2 9.28 2 6.5 2 4.5 3.5 3 5.5 3c1.54 0 2.99.99 3.57 2.36h1.86C11.51 3.99 12.96 3 14.5 3 16.5 3 18 4.5 18 6.5c0 2.78-2.4 4.86-6.55 9.18L10 17z"/></svg> Like {post.likes>0 && <span className="text-slate-500">({post.likes})</span>} </button> <button onClick={()=>setShowComments(s=>!s)} className="flex items-center gap-2 rounded px-2 py-1 hover:bg-slate-50"> üí¨ Comment {post.comments?.length>0 && <span className="text-slate-500">({post.comments.length})</span>} </button> <button className="flex items-center gap-2 rounded px-2 py-1 hover:bg-slate-50">‚Üó Share</button> </div> {showComments && ( <div className="mt-3 space-y-3"> {post.comments?.map(c=> ( <CommentThread key={c.id} comment={c} onAddReply={(text,images,files)=>onAddReply(c.id, text, images, files)} onOpenLightbox={(items,idx)=>openLightbox(items, idx)} /> ))} <form onSubmit={(e)=>{e.preventDefault(); onAddComment(cmt, cmtImages, cmtFiles); setCmt(""); setCmtImages([]); setCmtFiles([]);}} className="flex flex-col gap-2"> <div className="flex items-start gap-2"> <Avatar size="sm" url={currentUser?.photoUrl} name={currentUser?.name || "Me"} online /> <input value={cmt} onChange={e=>setCmt(e.target.value)} placeholder="Write a comment‚Ä¶" className="flex-1 border border-slate-100 rounded-full px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" /> <label className="text-xs px-2 py-1 border border-slate-100 rounded cursor-pointer">üì∑ <input type="file" accept="image/*" multiple className="hidden" onChange={onPickCmtImages}/> </label> <label className="text-xs px-2 py-1 border border-slate-100 rounded cursor-pointer">üìé <input type="file" multiple className="hidden" onChange={onPickCmtDocs} accept=".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.txt"/> </label> <button type="submit" className="rounded-full bg-blue-600 text-white px-4 py-2 text-sm font-semibold hover:bg-blue-700">Post</button> </div> {(cmtImages.length>0 || cmtFiles.length>0) && ( <div className="pl-10 space-y-2"> {cmtImages.length>0 && ( <div className="grid grid-cols-2 md:grid-cols-3 gap-2"> {cmtImages.map((img,i)=>(<img key={i} src={img.dataUrl} alt={img.name} className="w-full h-24 object-cover rounded" />))} </div> )} {cmtFiles.length>0 && ( <ul className="text-sm space-y-1"> {cmtFiles.map((f,i)=>(<li key={i} className="flex items-center gap-2">üìé <span>{f.name}</span></li>))} </ul> )} </div> )} </form> </div> )} </div> ); } /* ================== MAIN ================== */ export default function StudentDashboard() { const navigate = useNavigate(); const [user,setUser] = useState(()=>{ const raw = loadActiveUser(); const merged = { ...initialUser, ...(raw||{}) }; merged.country = normalizeCountry(merged.country || ""); merged.countryCode = ensureCountryCode(merged.country, merged.countryCode); return merged; }); // cross-tab & intra-tab user syncing useEffect(()=>{ const refresh = ()=>{ const raw = loadActiveUser(); if (!raw) return; const merged = { ...initialUser, ...raw }; merged.country = normalizeCountry(merged.country || ""); merged.countryCode = ensureCountryCode(merged.country, merged.countryCode); setUser(merged); }; window.addEventListener("storage", refresh); window.addEventListener("user:updated", refresh); return () => { window.removeEventListener("storage", refresh); window.removeEventListener("user:updated", refresh); }; },[]); const audKey = audienceKey(user); const facKey = facultyAudienceKey(user); const baseFac = FACULTY__${user.university}__${user.faculty}; const facYearKey = ${baseFac}__${user.year}; // ===== Seeded posts ===== const seeded = useMemo(()=>[ { id:"p3", createdAt: Date.now()-60*60*1000, authorType:"lecturer", author:"Dr. A. Lecturer", authorPhoto:"", authorProgram:user.faculty, time:"1h", audience:audKey, type:"Notes", title:"Week 3 Lab Tutorial", html:<p><strong>New tutorial</strong> uploaded for Week 3. Please review before the lab.</p>, images:[], files:[{name:"week3-tutorial.pdf"}], likes:5, liked:false, comments:[{id:"c1", author:user.name, authorPhoto:user.photoUrl, authorProgram:user.program, text:"Thanks doc! This helps a lot.", images:[], files:[], replies:[{id:"r1", author:"Dr. A. Lecturer", authorPhoto:"", authorProgram:user.faculty, text:"You're welcome. See you in lab.", images:[], files:[] }]}], }, { id:"p2", createdAt: Date.now()-5*60*60*1000, authorType:"student", author:"Scholarships Bot", authorPhoto:"", authorProgram:"Global", time:"5h", audience:"GLOBAL", type:"Scholarships", title:"Women in Tech 2025", html:<p>New scholarship: Women in Tech 2025 ‚Äî closes Sept 30. <a href="/scholarship">See details</a>.</p>, images:[], files:[], likes:3, liked:false, comments:[] }, { id:"p1", createdAt: Date.now()-24*60*60*1000, authorType:"student", author:"Course Admin", authorPhoto:"", authorProgram:user.program, time:"Yesterday", audience:facKey, type:"Assignments", title:"Midterm Review Session", html:<p>Midterm review session posted. Slides are available in <a href="/eduinfo">EduInfo</a>.</p>, images:[], files:[], likes:2, liked:false, comments:[] }, // eslint-disable-next-line react-hooks/exhaustive-deps ],[]); const [posts,setPosts] = useState(()=> { const stored = safeParse(localStorage.getItem("posts")); return stored && Array.isArray(stored) ? stored : seeded; }); // Keep posts in localStorage + broadcast to all tabs useEffect(()=>{ try { localStorage.setItem("posts", JSON.stringify(posts)); } catch { try { const lean = posts.map(p => ({ ...p, images: (p.images||[]).map(img => ({ id: img.id, name: img.name, mime: img.mime })), files: (p.files||[]).map(f => ({ id: f.id, name: f.name, mime: f.mime })), comments: (p.comments||[]).map(c => ({ ...c, images: (c.images||[]).map(img => ({ id: img.id, name: img.name, mime: img.mime })), files: (c.files||[]).map(f => ({ id: f.id, name: f.name, mime: f.mime })), replies: (c.replies||[]).map(r => ({ ...r, images: (r.images||[]).map(img => ({ id: img.id, name: img.name, mime: img.mime })), files: (r.files||[]).map(f => ({ id: f.id, name: f.name, mime: f.mime })), })), })), })); localStorage.setItem("posts", JSON.stringify(lean)); } catch {} } window.dispatchEvent(new Event("posts:updated")); },[posts]); /* ===== Left-sidebar ‚Äúnew‚Äù chips ===== */ const [showLecturerOnly,setShowLecturerOnly]=useState(false); const [showFacultyOnly,setShowFacultyOnly]=useState(false); const [showMineOnly,setShowMineOnly]=useState(false); const [filterType,setFilterType]=useState("All"); const TYPES_SEEN_KEY = lastSeenTypes_${user.id}; const [lastSeenByType, setLastSeenByType] = useState(()=> safeParse(localStorage.getItem(TYPES_SEEN_KEY)) || {}); useEffect(()=>{ localStorage.setItem(TYPES_SEEN_KEY, JSON.stringify(lastSeenByType)); },[lastSeenByType]); const latestByType = useMemo(()=>{ const map = {}; for (const p of posts) { const t = p.type || "Notes"; const ts = p.createdAt || 0; map[t] = Math.max(map[t] || 0, ts); } return map; }, [posts]); const markTypeSeen = (t) => setLastSeenByType(prev => ({ ...prev, [t]: latestByType[t] || Date.now() })); const FAC_NEW_KEY = lastSeenFaculty_${user.id}; const isForMyFaculty = (aud) => aud === baseFac || aud === ${baseFac}__${user.year}; const latestFacTs = useMemo(()=>{ let max = 0; posts.forEach(p=>{ if (isForMyFaculty(p.audience)) max = Math.max(max, p.createdAt || 0); }); return max; },[posts, user.university, user.faculty, user.year]); const [lastSeenFacTs, setLastSeenFacTs] = useState(()=> Number(localStorage.getItem(FAC_NEW_KEY) || 0)); useEffect(()=>{ localStorage.setItem(FAC_NEW_KEY, String(lastSeenFacTs||0)); },[lastSeenFacTs]); const hasNewFacultyPosts = latestFacTs > lastSeenFacTs; // Lightweight cross-tab ‚Äúnew‚Äù flags for lecturer posts const [hasNewLecturer, setHasNewLecturer] = useState(false); const [hasNewFacultySignal, setHasNewFacultySignal] = useState(false); const computeNewFlags = () => { const ns = safeParse(localStorage.getItem("newSignals")) || {}; const progLect = (ns[audKey]?.lecturer || 0) > 0; const facLect = (ns[facYearKey]?.lecturer || 0) > 0 || (ns[baseFac]?.lecturer || 0) > 0; setHasNewLecturer(progLect || facLect); setHasNewFacultySignal(facLect); }; useEffect(() => { computeNewFlags(); const onStorage = (e) => { if (!e || e.key === "newSignals" || e.key === "posts") computeNewFlags(); }; const onUpdated = () => computeNewFlags(); window.addEventListener("storage", onStorage); window.addEventListener("posts:updated", onUpdated); return () => { window.removeEventListener("storage", onStorage); window.removeEventListener("posts:updated", onUpdated); }; }, [audKey, facYearKey, baseFac]); const onToggleLecturerOnly = () => { setShowLecturerOnly(v => { const next = !v; if (next) { const ns = safeParse(localStorage.getItem("newSignals")) || {}; if (ns[audKey]) ns[audKey].lecturer = 0; if (ns[facYearKey]) ns[facYearKey].lecturer = 0; if (ns[baseFac]) ns[baseFac].lecturer = 0; localStorage.setItem("newSignals", JSON.stringify(ns)); setHasNewLecturer(false); } return next; }); }; const onToggleFacultyOnly = () => { setShowFacultyOnly(v => { const next = !v; if (next) { setLastSeenFacTs(latestFacTs || Date.now()); const ns = safeParse(localStorage.getItem("newSignals")) || {}; if (ns[facYearKey]) ns[facYearKey].lecturer = 0; if (ns[baseFac]) ns[baseFac].lecturer = 0; localStorage.setItem("newSignals", JSON.stringify(ns)); setHasNewFacultySignal(false); } return next; }); }; // ===== IDLE TIMER (unchanged) ===== const [idleWarning,setIdleWarning] = useState(false); const [countdown,setCountdown] = useState(60); const idleTimerRef = useRef(null); const countdownRef = useRef(null); const resetIdleTimer = ()=>{ if (idleTimerRef.current) clearTimeout(idleTimerRef.current); idleTimerRef.current = setTimeout(()=>{ setIdleWarning(true); setCountdown(60); countdownRef.current = setInterval(()=>{ setCountdown(c=>{ if (c<=1) { clearInterval(countdownRef.current); setIdleWarning(false); navigate("/login?role=student"); } return c-1; }); },1000); }, 20*60*1000); }; useEffect(()=>{ const bump=()=>{ if (!idleWarning) resetIdleTimer(); }; window.addEventListener("mousemove",bump); window.addEventListener("keydown",bump); window.addEventListener("click",bump); resetIdleTimer(); return ()=>{ window.removeEventListener("mousemove",bump); window.removeEventListener("keydown",bump); window.removeEventListener("click",bump); if (idleTimerRef.current) clearTimeout(idleTimerRef.current); if (countdownRef.current) clearInterval(countdownRef.current); }; // eslint-disable-next-line react-hooks/exhaustive-deps },[idleWarning]); /* ===== Banner/Avatar (unchanged) ===== */ const onPickBanner = async (e)=>{ const f = e.target.files?.[0]; if (!f || !f.type.startsWith("image/")) return; const dataUrl = await fileToDownscaledDataURL(f, 1200, 320, 0.82, 460); setUser(u=>{ const next = { ...u, bannerUrl:dataUrl }; saveAndBroadcastUser(next); return next; }); }; const onPickAvatar = async (e)=>{ const f = e.target.files?.[0]; if (!f || !f.type.startsWith("image/")) return; const dataUrl = await fileToDownscaledDataURL(f, 320, 320, 0.86, 260); setUser(u=>{ const next = { ...u, photoUrl:dataUrl }; saveAndBroadcastUser(next); return next; }); }; /* ===== Composer ===== */ const [composerOpen,setComposerOpen]=useState(false); const editorRef = useRef(null); const [composerType,setComposerType]=useState("Notes"); const [composerTitle,setComposerTitle] = useState(""); const [toFaculty,setToFaculty]=useState(false); const [imagePreviews,setImagePreviews]=useState([]); const [docFiles,setDocFiles]=useState([]); const exec = (cmd, value=null)=>{ document.execCommand(cmd,false,value); editorRef.current?.focus(); }; const addLink = ()=>{ const url = prompt("Enter URL (include https://)"); if (url) exec("createLink", url); }; const onPickImages = async (e)=>{ const files = Array.from(e.target.files||[]).filter(f=>f.type.startsWith("image/")); const slots = Math.max(0, 6 - imagePreviews.length); const chosen = files.slice(0, slots); const dataUrls = await Promise.all(chosen.map(f=>fileToDownscaledDataURL(f, 1280, 1280, 0.82, 420))); const next = dataUrls.map((dataUrl,i)=>({ name: chosen[i].name, dataUrl })); setImagePreviews(arr=>[...arr, ...next]); e.target.value=""; }; const onPickDocs = async (e)=>{ const files = Array.from(e.target.files||[]); const mapped = await Promise.all(files.map(async f=>({ name:f.name, mime:f.type||"application/octet-stream", dataUrl: await readFileAsDataURL(f) }))); setDocFiles(arr=>[...arr, ...mapped]); e.target.value=""; }; const handlePaste = (e) => { e.preventDefault(); const text = e.clipboardData?.getData("text/plain") || ""; if (document.queryCommandSupported("insertText")) { document.execCommand("insertText", false, text); } else { const sel = window.getSelection(); if (!sel || !sel.rangeCount) return; sel.deleteFromDocument(); sel.getRangeAt(0).insertNode(document.createTextNode(text)); } }; // Persist attachments to IDB async function persistAttachments(images=[], files=[]) { const imgDescs = []; for (let i=0;i<images.length;i++) { const src = images[i]; const id = att_img_${Date.now()}_${Math.random().toString(36).slice(2)}; const blob = dataURLtoBlob(src.dataUrl); await idbSet(id, blob); const thumb = await makeThumb(src.dataUrl, 360, 360, 0.72); imgDescs.push({ id, name: src.name || "image.jpg", mime: blob.type || "image/jpeg", thumb }); } const fileDescs = []; for (let i=0;i<files.length;i++) { const src = files[i]; const id = att_file_${Date.now()}_${Math.random().toString(36).slice(2)}; const blob = dataURLtoBlob(src.dataUrl); await idbSet(id, blob); fileDescs.push({ id, name: src.name || "file", mime: blob.type || src.mime || "application/octet-stream" }); } return { imgDescs, fileDescs }; } // Create post const onPost = async (e)=>{ e.preventDefault(); const html = (editorRef.current?.innerHTML || "").trim(); if (!html && imagePreviews.length===0 && docFiles.length===0) return; const audience = toFaculty ? facultyYearAudienceKey({ university:user.university, faculty:user.faculty, year:user.year }) : audKey; const { imgDescs, fileDescs } = await persistAttachments(imagePreviews, docFiles); const newPost = { id:p${Date.now()}, createdAt: Date.now(), authorType:"student", author:user.name, authorPhoto:user.photoUrl, authorProgram: toFaculty ? ${user.faculty} ‚Ä¢ ${user.year} : user.program, time:"Just now", audience, type:composerType, title: (composerTitle || "").trim(), html, images: imgDescs, files: fileDescs, likes:0, liked:false, comments:[] }; setPosts(p=>[newPost, ...p]); // Reset if (editorRef.current) editorRef.current.innerHTML = ""; setImagePreviews([]); setDocFiles([]); setComposerType("Notes"); setToFaculty(false); setComposerOpen(false); setComposerTitle(""); }; /* ===== Likes/Comments/Replies ===== */ const toggleLike = (postId)=> setPosts(p=> p.map(x=> x.id===postId ? {...x, liked:!x.liked, likes:x.liked?x.likes-1:x.likes+1} : x)); const addComment = async (postId,text,images=[],files=[])=>{ if (!text.trim() && images.length===0 && files.length===0) return; const { imgDescs, fileDescs } = await persistAttachments(images, files); setPosts(p=> p.map(x=> x.id===postId ? { ...x, comments:[...(x.comments||[]), { id:c${Date.now()}, author:user.name, authorPhoto:user.photoUrl, authorProgram:user.program, text:text.trim(), images:imgDescs, files:fileDescs, replies:[] }] } : x)); }; const addReply = async (postId,commentId,text,images=[],files=[])=>{ if (!text.trim() && images.length===0 && files.length===0) return; const { imgDescs, fileDescs } = await persistAttachments(images, files); setPosts(p=> p.map(x=> x.id===postId ? { ...x, comments:x.comments.map(c=> c.id===commentId ? { ...c, replies:[...(c.replies||[]), { id:r${Date.now()}, author:user.name, authorPhoto:user.photoUrl, authorProgram:user.program, text:text.trim(), images:imgDescs, files:fileDescs }] } : c) } : x)); }; /* ===== Post refs for scroll-to from notifications ===== */ const postRefs = useRef({}); // id -> element const [highlightPostId, setHighlightPostId] = useState(null); const scrollToPost = (postId) => { const el = postRefs.current[postId]; if (el && typeof el.scrollIntoView === "function") { el.scrollIntoView({ behavior: "smooth", block: "start" }); setHighlightPostId(postId); setTimeout(()=> setHighlightPostId(null), 2500); } }; /* ===== Showing bar + Search ===== */ const [showingTab, setShowingTab] = useState("Newest"); // "Top" | "Newest" | "Answered" const [search, setSearch] = useState(""); const matchesSearch = (p) => { const q = search.trim().toLowerCase(); if (!q) return true; const plain = stripHtml(p.html||"").toLowerCase(); const title = (p.title||"").toLowerCase(); const author = (p.author||"").toLowerCase(); const type = (p.type||"").toLowerCase(); const files = (p.files||[]).map(f=> (f.name||"").toLowerCase()).join(" "); const commentText = (p.comments||[]).map(c=> [c.author?.toLowerCase()||"", (c.text||"").toLowerCase()]).flat().join(" "); return [plain,title,author,type,files,commentText].some(s => s.includes(q)); }; /* ===== Filtering ===== */ const [hasNewLecturerToast, setHasNewLecturerToast] = useState(null); // in Part 2 we render the toast // Robust unseen counter: counts both lecturer + student posts, respects Clear All const [notifOpen,setNotifOpen] = useState(false); const [unseenCount,setUnseenCount] = useState(0); const [clearedAt, setCleared