// src/components/chat/ChatDock.jsx
import { useEffect, useMemo, useState } from "react";
import ChatWindow from "./ChatWindow";
import { upsertUser, getLecturers } from "../../lib/usersApi";
import {
  collection,
  doc,
  getDoc,
  onSnapshot,
  orderBy,
  query,
  serverTimestamp,
  setDoc,
  where,
} from "firebase/firestore";
import { db } from "../../lib/firebase";

/* ---------- helpers ---------- */
function getCurrentUser() {
  try {
    const raw = localStorage.getItem("currentUser");
    const u = raw ? JSON.parse(raw) : null;
    if (!u) return null;
    if (!u.uid) u.uid = u.id || u.userId || u.email || "";
    if (!u.role) {
      const p =
        (typeof window !== "undefined" ? window.location.pathname : "") || "";
      if (p.includes("student-dashboard")) u.role = "student";
      if (p.includes("lecturer-dashboard")) u.role = "lecturer";
    }
    return u;
  } catch {
    return null;
  }
}
function canon(s = "") {
  return String(s)
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/[^\p{L}\p{N}]+/gu, " ")
    .trim();
}
function displayNameWithTitle(p) {
  const t = (p?.title || "").trim();
  const n = (p?.name || "").trim();
  return t ? `${t}. ${n}` : n;
}
function isOnline(person) {
  const raw =
    person?.updatedAt || person?.updated_at || person?.lastSeen || null;
  if (!raw) return false;
  const ts = typeof raw === "number" ? raw : Date.parse(raw);
  if (!ts) return false;
  return Date.now() - ts < 3 * 60 * 1000; // 3 minutes
}

function MyAvatar({ url, name }) {
  const src =
    url || `https://ui-avatars.com/api/?name=${encodeURIComponent(name || "Me")}`;
  return (
    <div className="relative h-7 w-7 rounded-full overflow-hidden">
      <img src={src} alt={name || "Me"} className="h-full w-full object-cover" />
      <span
        className="absolute -bottom-0.5 -right-0.5 h-3 w-3 rounded-full bg-emerald-500 ring-2 ring-white"
        title="Online"
      />
    </div>
  );
}

function PersonRow({ person, onOpen }) {
  const online = isOnline(person);
  const titleName = displayNameWithTitle(person);
  const photo =
    person.photoURL ||
    person.photoUrl ||
    `https://ui-avatars.com/api/?name=${encodeURIComponent(person.name || "U")}`;
  return (
    <button
      onClick={() => onOpen(person)}
      className="flex w-full items-center gap-2 rounded px-2 py-2 hover:bg-slate-50 text-left"
      title={titleName}
    >
      <div className="relative">
        <img
          src={photo}
          className="h-8 w-8 rounded-full object-cover"
          alt={person.name || "User"}
        />
        <span
          className={`absolute -bottom-0.5 -right-0.5 h-3 w-3 rounded-full ring-2 ring-white ${
            online ? "bg-emerald-500" : "bg-slate-300"
          }`}
          title={online ? "Online" : "Away"}
        />
      </div>
      <div className="min-w-0">
        <div className="truncate text-sm font-medium">{titleName || "User"}</div>
        {person.title && (
          <div className="truncate text-xs text-slate-500">{person.title}</div>
        )}
      </div>
    </button>
  );
}

function RecentRow({ item, onOpen }) {
  // item: { uid, name, title, photoURL, lastText, unread }
  const titleName = displayNameWithTitle(item);
  const photo =
    item.photoURL ||
    `https://ui-avatars.com/api/?name=${encodeURIComponent(item.name || "U")}`;
  return (
    <button
      onClick={() => onOpen(item)}
      className="flex w-full items-center gap-2 rounded px-2 py-2 hover:bg-slate-50 text-left"
      title={titleName}
    >
      <img src={photo} className="h-8 w-8 rounded-full object-cover" alt={item.name || "User"} />
      <div className="min-w-0 flex-1">
        <div className="flex items-center justify-between gap-2">
          <div className="truncate text-sm font-medium">{titleName}</div>
          {item.unread ? (
            <span className="ml-2 inline-flex items-center justify-center h-5 min-w-[20px] rounded-full bg-blue-600 text-white text-xs px-1">
              {item.unread}
            </span>
          ) : null}
        </div>
        <div className="truncate text-xs text-slate-500">{item.lastText || ""}</div>
      </div>
    </button>
  );
}

/* ---------- dock ---------- */
export default function ChatDock({ offsetRightClass = "right-28 md:right-36" }) {
  const me = getCurrentUser();
  const [openList, setOpenList] = useState(false);
  const [activePeer, setActivePeer] = useState(null);
  const [search, setSearch] = useState("");

  const [lecturers, setLecturers] = useState([]); // REST list (faculty)
  const [recents, setRecents] = useState([]); // Firestore recent chats

  const myName = me?.name || me?.displayName || "";
  const myPhoto = me?.photoURL || me?.photoUrl || "";

  /* 1) Upsert me in your REST DB for presence-ish updatedAt */
  useEffect(() => {
    if (!me?.uid) return;
    upsertUser(me).catch(console.error);
  }, [me?.uid]);

  /* 2) Load lecturers (all visible; search only filters locally) */
  useEffect(() => {
    if (!me?.university || !me?.faculty) return;
    let cancelled = false;

    const cacheKey = `lecturers:${me.university}::${me.faculty}`;
    try {
      const raw = sessionStorage.getItem(cacheKey);
      if (raw) setLecturers(JSON.parse(raw));
    } catch {}

    getLecturers(me.university, me.faculty)
      .then((data) => {
        if (cancelled) return;
        if (data?.ok) {
          const list = (data.lecturers || []).map((p) => ({
            ...p,
            // normalize fields
            uid: p.uid || p.id || p.email,
            name: p.name || p.displayName || "",
            title: p.title || "",
            photoURL: p.photoURL || p.photoUrl || "",
          }));
          setLecturers(list);
          try {
            sessionStorage.setItem(cacheKey, JSON.stringify(list));
          } catch {}
        }
      })
      .catch(console.error);

    return () => {
      cancelled = true;
    };
  }, [me?.university, me?.faculty]);

  /* 3) Firestore: subscribe to my recent chats for Focused (+ unread) */
  useEffect(() => {
    if (!me?.uid) return;
    const chatsRef = collection(db, "chats");
    const qy = query(
      chatsRef,
      where("members", "array-contains", String(me.uid)),
      orderBy("updatedAt", "desc")
    );
    const unsub = onSnapshot(qy, async (snap) => {
      const rows = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
      const items = [];

      for (const c of rows) {
        const other = (c.members || []).find((m) => m !== String(me.uid));
        if (!other) continue;

        // prefer details from lecturers list (has title, photo, presence-ish)
        let found =
          lecturers.find((p) => String(p.uid) === String(other)) || null;

        if (!found) {
          // try to read a /users doc (optional)
          try {
            const udoc = await getDoc(doc(db, "users", String(other)));
            if (udoc.exists()) {
              const u = udoc.data();
              found = {
                uid: other,
                name: u?.name || "User",
                title: u?.title || "",
                photoURL: u?.photoURL || "",
              };
            }
          } catch {}
        }

        const lastText = c?.lastMessage?.text || "";
        // unread logic: if last message not mine and I haven't marked read after updatedAt
        const readTs = c?.readBy?.[String(me.uid)]?.toMillis
          ? c.readBy[String(me.uid)].toMillis()
          : c?.readBy?.[String(me.uid)] || 0;
        const updatedMs = c?.updatedAt?.toMillis
          ? c.updatedAt.toMillis()
          : Date.parse(c?.updatedAt) || 0;
        const unread = c?.lastMessage?.senderId &&
          String(c.lastMessage.senderId) !== String(me.uid) &&
          (!readTs || readTs < updatedMs)
            ? 1
            : 0;

        items.push({
          uid: String(other),
          name: found?.name || "User",
          title: found?.title || "",
          photoURL: found?.photoURL || "",
          lastText,
          unread,
        });
      }

      setRecents(items);
      try {
        localStorage.setItem("recentPeers", JSON.stringify(items));
      } catch {}
    });

    return () => unsub();
  }, [me?.uid, lecturers]);

  /* 4) Search filter */
  const qStr = (search || "").toLowerCase().trim();
  const people = useMemo(() => {
    if (!qStr) return lecturers;
    return (lecturers || []).filter((p) => {
      const dn = displayNameWithTitle(p).toLowerCase();
      return (
        dn.includes(qStr) ||
        (p.email || "").toLowerCase().includes(qStr) ||
        (p.title || "").toLowerCase().includes(qStr)
      );
    });
  }, [lecturers, qStr]);

  if (!me) return null;

  const chatRightStyle = { right: "calc(9rem + 60px)" }; // keeps clear of the bell

  /* Open a chat + mark read immediately */
  async function openPeer(peer) {
    setActivePeer({
      uid: peer.uid,
      name: peer.name,
      photoURL: peer.photoURL,
      title: peer.title,
      email: peer.email, // not displayed in UI, passed along for consistency
    });

    try {
      const chatId = [String(me.uid), String(peer.uid)].sort().join("__");
      const chatDoc = doc(db, "chats", chatId);
      await setDoc(
        chatDoc,
        {
          id: chatId,
          members: [String(me.uid), String(peer.uid)],
          updatedAt: serverTimestamp(),
          readBy: {
            [String(me.uid)]: serverTimestamp(),
          },
        },
        { merge: true }
      );
    } catch (e) {
      console.error("mark read failed", e);
    }
  }

  return (
    <>
      {/* Collapsed pill: avatar + "Messaging" */}
      {!openList && (
        <button
          onClick={() => setOpenList(true)}
          className={`fixed bottom-4 ${offsetRightClass} z-[68] flex items-center gap-2 rounded-full bg-white text-slate-900 px-3 py-2 shadow-lg border border-slate-200`}
          title="Messaging"
        >
          <MyAvatar url={myPhoto} name={myName} />
          <span className="font-medium">Messaging</span>
          <svg
            className="-mr-1 h-4 w-4 text-slate-500"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
          >
            <path d="M6 9l6 6 6-6" />
          </svg>
        </button>
      )}

      {/* Expanded panel */}
      {openList && (
        <div
          className={`fixed bottom-4 ${offsetRightClass} z-[68] w-80 rounded-xl border border-slate-200 bg-white shadow-xl`}
        >
          <div className="flex items-center justify-between border-b px-3 py-2">
            <div className="flex items-center gap-2">
              <MyAvatar url={myPhoto} name={myName} />
              <div className="font-semibold">Messaging</div>
            </div>
            <button
              onClick={() => setOpenList(false)}
              className="rounded px-2 py-1 text-sm text-slate-600 hover:bg-slate-100"
              title="Collapse"
            >
              Collapse
            </button>
          </div>

          {/* Search */}
          <div className="px-3 pt-2 pb-2 border-b">
            <div className="flex items-center gap-2 rounded-full border border-slate-200 bg-slate-50 px-3 py-2">
              <svg
                className="h-4 w-4 text-slate-500"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <input
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                placeholder="Search messages"
                className="flex-1 bg-transparent outline-none text-sm"
              />
            </div>
          </div>

          {/* People (lecturers) */}
          <div className="max-h-96 overflow-auto px-2 py-2">
            <div className="px-2 py-1 text-xs font-semibold text-slate-500">
              People
            </div>
            {people && people.length ? (
              <ul className="divide-y">
                {people.map((p) => (
                  <li key={p.uid}>
                    <PersonRow person={p} onOpen={openPeer} />
                  </li>
                ))}
              </ul>
            ) : (
              <div className="px-2 py-10 text-center text-sm text-slate-500">
                No lecturers found yet.
              </div>
            )}

            {/* Recent / Focused */}
            <div className="mt-3 px-2 py-1 text-xs font-semibold text-slate-500">
              Focused
            </div>
            {recents && recents.length ? (
              <ul className="divide-y">
                {recents.map((r) => (
                  <li key={`rec-${r.uid}`}>
                    <RecentRow item={r} onOpen={openPeer} />
                  </li>
                ))}
              </ul>
            ) : (
              <div className="px-2 pb-3 text-sm text-slate-500">
                No conversations yet.
              </div>
            )}
          </div>
        </div>
      )}

      {/* Floating chat window (left of dock; wide) */}
      {activePeer && (
        <div
          className="fixed bottom-4 z-[69] max-w-[92vw]"
          style={{ ...{ right: "calc(9rem + 60px)" }, width: "min(92vw, 640px)" }}
        >
          <ChatWindow
            me={{ uid: me.uid, name: myName, photoURL: myPhoto, email: me.email }}
            peer={activePeer}
            onClose={() => setActivePeer(null)}
          />
        </div>
      )}
    </>
  );
}